import numpy as npimport matplotlib.pyplot as pltfrom math import combfrom scipy.interpolate import make_interp_splinefrom scipy.special import logsumexpkB = 1T = 1beta = 1/(kB*T)# --- Your classes, unchanged ---class Link:    def __init__(self, a, parity):        self.parity = parity        self.a = aclass RubberBand:    def __init__(self, N, kBT = kB*T, force = 0, biased = False):        self.N = N        self.band = []        self.rng = np.random.default_rng()        self.a = 1        self.directions = (-1, 1)        self.L = None                      # cache        self.kBT = kBT        self.force = force        self.biased = biased    def p_pos(self):        return 0.5 * (1 + np.tanh((1/self.kBT)*self.force*self.a))        def create_band(self):        if self.biased:            no_pos = 0            self.band = []            for _ in range(self.N):                prob_pos = self.p_pos()                parity = self.rng.choice(self.directions, p = (1-prob_pos, prob_pos))                self.band.append(Link(self.a, parity))                if parity > 0:                    no_pos += 1            return self.band, no_pos        else:            no_pos = 0            self.band = []                     # reset            for _ in range(self.N):                parity = self.rng.choice(self.directions)                self.band.append(Link(self.a, parity))                if parity > 0:                    no_pos += 1                # clearer: count +1’s            return self.band, no_pos    def length(self):        _, pos = self.create_band()        self.L = self.a * (2*pos - self.N) # store once        return self.L    def w(self, force, beta=1.0):        if self.L is None:                 # ensure we have the same microstate            self.length()        return np.exp(beta * force * self.L)# --- Monte Carlo sampling ---no_rubber_bands = 1e4no_links = 100def Omega(N, n):    """    Compute Ω(N, n) = N! / (n!(N-n)!)    Works with scalars or NumPy arrays.    """    n = np.asarray(n, dtype=int)    return np.array([comb(N, int(ni)) for ni in n])def sample_biased_lengths(N, f, M, rng=None):    if rng is None:        rng = np.random.default_rng()    L = np.empty(M, dtype=float)    for i in range(M):        rb = RubberBand(N, force=f, biased=True)               L[i] = rb.length()    return L# --- Draw samples ---L = [RubberBand(no_links).length() for _ in range(int(no_rubber_bands))]# --- Analytical distribution on grid (for plotting density overlay) ---Lgrid = np.arange(-no_links, no_links + 1, 2)n = (Lgrid + no_links) // 2omega = Omega(no_links, n)pmf_density = (omega / 2**no_links) / 2.0   # divide by bin width = 2a         x = np.linspace(Lgrid.min(), Lgrid.max(), 1000)y = make_interp_spline(Lgrid, pmf_density)(x)# --- Histogram binning (counts, not densities) ---edges = np.arange(Lgrid.min() - 1, Lgrid.max() + 1 + 2, 2)counts, _ = np.histogram(L, bins=edges, density=False)centers = 0.5 * (edges[:-1] + edges[1:])mcSamples = len(L)# --- Map exact PMF to each histogram bin center ---yTh = np.zeros_like(centers, dtype=float)                    # theoretical prob per binvalid = ((centers + no_links) % 2 == 0) & (np.abs(centers) <= no_links)idx = ((centers[valid] + no_links) // 2).astype(int)pmf_grid = Omega(no_links, (Lgrid + no_links)//2) / (2**no_links)  # P(L) on LgridyTh[valid] = pmf_grid[idx]                                         # prob for that bin# --- Chi^2 on counts with empty-bin guard (>5 expected) ---chi2 = 0.0ndf = 0for mc, th in zip(counts, yTh):    pth = mcSamples * th              # expected COUNT in this bin    if pth > 5:                       # guard against (almost) empty bins        chi2 += (mc - pth)**2 / pth        ndf += 1# subtract 1 for normalizationndf -= 1chi2_ndf = chi2 / ndf# --- Ratio (counts / expected) for bins with positive expectation ---expected = mcSamples * yThratio_valid_mask = (expected > 0)ratio = np.ones_like(centers)ratio[ratio_valid_mask] = counts[ratio_valid_mask] / expected[ratio_valid_mask]# --- Plot setup ---fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True,                               figsize=(7, 5),                               gridspec_kw={'height_ratios': [3, 1]})# --- Top panel: P(L) ---ax1.hist(L, bins=edges, density=True, alpha=0.35,         edgecolor='k', label='Monte Carlo')ax1.plot(x, y, 'k-', lw=2, label='Exact solution')ax1.text(-0.9 * no_links, 0.075, rf'$\chi^2/\mathrm{{ndf}} = {chi2_ndf:.3f}$',         fontsize=12)ax1.text(0.2 * no_links, 0.075, rf'No of Bands: {int(no_rubber_bands)}',         fontsize=12)ax1.set_ylabel(r'$P(L/a)$', fontsize=14)ax1.legend(frameon=False)ax1.set_xlim(-no_links, no_links)# --- Bottom panel: ratio (counts / expected) ---ax2.plot(centers[ratio_valid_mask], ratio[ratio_valid_mask], 'b-')ax2.axhline(1.0, color='k', lw=1)ax2.set_xlabel(r'$L/a$', fontsize=14)ax2.set_ylabel('Counts / expected', fontsize=12)ax2.set_ylim(0.8, 1.2)plt.tight_layout()plt.show()# -------- Task 2 --------# ----- set parameters -----N = no_linksa = 1.0# ---- Monte Carlo using the class weight ----beta = 1.0f = 0.01no_links = 100no_rubber_bands = 1e4bands = [RubberBand(no_links) for _ in range(int(no_rubber_bands))]L = np.array([rb.length() for rb in bands])      # each rb now has rb.L fixeddef weight(f,beta):    return np.array([rb.w(f, beta) for rb in bands])w = weight(f,beta)    # weights from the class (same microstate)# ---- bins aligned to support ----Lgrid = np.arange(-no_links, no_links+1, 2)edges = np.arange(Lgrid.min()-1, Lgrid.max()+1+2, 2)binw = edges[1] - edges[0]centers = 0.5*(edges[:-1] + edges[1:])# ---- MC density with weights ----counts, _ = np.histogram(L, bins=edges, weights=w)Wtot = w.sum()mc_density = counts / (Wtot * binw)# ---- analytic Pf(L) = Ω e^{β f L} / Z and density ----n_grid = ((Lgrid + no_links)//2).astype(int)omega_grid = Omega(no_links, n_grid)Z = np.sum(omega_grid * np.exp(beta*f*Lgrid))Pf_density = (omega_grid * np.exp(beta*f*Lgrid) / Z) / binw# smooth analytic curvex = np.linspace(Lgrid.min(), Lgrid.max(), 1000)y = make_interp_spline(Lgrid, Pf_density)(x)# ---- ratio on valid centers ----valid = ((centers + no_links) % 2 == 0) & (np.abs(centers) <= no_links)n_centers = ((centers[valid] + no_links)//2).astype(int)ana = (Omega(no_links, n_centers) * np.exp(beta*f*centers[valid]) / Z) / binwratio = mc_density[valid] / ana# ---- plots ----fig, (ax1, ax2) = plt.subplots(2,1,sharex=True,figsize=(7,5),gridspec_kw={'height_ratios':[3,1]})ax1.hist(L, bins=edges, weights=w, density=True, alpha=0.35, edgecolor='k', label='Monte Carlo')ax1.plot(x, y, 'k-', lw=2, label='Exact solution')ax1.legend(frameon=False); ax1.set_ylabel(r'$P(L/a)$'); ax1.set_xlim(-no_links, no_links)ax1.set_title(f"Number of Bands: {int(no_rubber_bands)}   Force: {f}")ax2.plot(centers[valid], ratio, 'b-'); ax2.axhline(1, color='k', lw=1)ax2.set_xlabel(r'$L/a$'); ax2.set_ylabel('Ratio MC/exact'); ax2.set_ylim(0.8, 1.2)plt.tight_layout(); plt.show()# reuse the same bands you already created so reweighting is validL_arr = np.array([rb.L for rb in bands])  # cached lengths from your bandsdef mu_eff(flow, fhigh):    fvals = np.linspace(flow, fhigh, 20)    mu = []    for fval in fvals:        logw = beta * fval * L_arr                       # log weights        s1 = logsumexp(logw)                             # log(sum w)        s2 = logsumexp(2.0 * logw)                       # log(sum w^2)        mu_eff_val = np.exp(2.0 * s1 - s2)               # (sum w)^2 / sum w^2        mu.append(mu_eff_val)    return fvals, np.array(mu)fvals, mueff = mu_eff(0.0, 1.0)plt.figure()plt.plot(fvals, mueff)plt.xlabel("Force f"); plt.ylabel(r"$\mu_{\mathrm{eff}}$")plt.title(r'$\mu_{\mathrm{eff}}$ as a function of force $f$')plt.tight_layout(); plt.show()# ------- Task3 -------# ----- set parameters -----N = no_linksa = 1.0# ---- Monte Carlo using the class weight ----beta = 1.0kBT = 1no_links = 100no_rubber_bands = 1e4fvals_small = np.linspace(0, 0.1, 30)fvals_med = np.linspace(0.1, 1, 30)def avg_L(f, it):    it = int(it)    vals = np.empty(it, dtype=float)    for i in range(it):        vals[i] = RubberBand(no_links, force=f, biased=True).length()    mean = vals.mean()    std  = vals.std(ddof=1)    return np.array([mean, std])def ana_exp_L(f):    rb = RubberBand(no_links, force=f, biased = True)    nb = rb.N    ab = rb.a    betab = 1/rb.kBT    return nb*ab*np.tanh(betab*f*ab)def hookes(f):    rb = RubberBand(no_links, force=f, biased = True)    nb = rb.N    ab = rb.a    betab = 1/rb.kBT    return nb*f*betab*ab**2Ls_small_f = np.array([avg_L(fi, no_rubber_bands) for fi in fvals_small])Ls_med_f = np.array([avg_L(fi, no_rubber_bands) for fi in fvals_med])small_fit_coeff = 1/(np.polyfit(fvals_small, Ls_small_f[:,0][:],1)[0])med_fit_coeff = 1/(np.polyfit(fvals_med, Ls_med_f[:,0],1)[0])L_small_f_ana = [ana_exp_L(fi) for fi in fvals_small]L_med_f_ana = [ana_exp_L(fi) for fi in fvals_med]L_small_f_hooke = [hookes(fi) for fi in fvals_small]L_med_f_hooke = [hookes(fi) for fi in fvals_med]print(f"keff small f range: {small_fit_coeff}, theoretical spring constant: {kBT/(N*a**2)}")print(f"keff smedium f range: {small_fit_coeff}, theoretical spring constant: {kBT/(N*a**2)}")plt.figure()plt.plot(fvals_small, Ls_small_f[:,0], label="MC")plt.plot(fvals_small, L_small_f_ana, label="Analytical")plt.plot(fvals_small, L_small_f_hooke, label="Hooke's Law")plt.xlabel("Force f")plt.ylabel(r"Average length $\langle L \rangle$")plt.title("Average length vs force in small force range")plt.legend()plt.show()plt.figure()plt.plot(fvals_small, Ls_small_f[:,1])plt.xlabel("Force f")plt.ylabel(r"Std")plt.title("Standard deviation of length L vs force in small force range")plt.show()plt.figure()plt.plot(fvals_med, Ls_med_f[:,0], label="MC")plt.plot(fvals_med, L_med_f_ana, label="Analytical")plt.plot(fvals_med, L_med_f_hooke, label="Hooke's Law")plt.xlabel("Force f")plt.ylabel(r"Average length $\langle L \rangle$")plt.title("Average length vs force in medium force range")plt.legend()plt.show()plt.figure()plt.plot(fvals_med, Ls_med_f[:,1])plt.xlabel("Force f")plt.ylabel(r"Std")plt.title("Standard deviation of length L vs force in medium force range")plt.show()# analytic Pf(L) on the discrete support; numerically stable (for plotting overlay)def analytic_Pf_density(N, f, a=1.0, beta=1.0):    Lgrid = a * np.arange(-N, N+1, 2)                 # allowed L    n = ((Lgrid/a + N)//2).astype(int)    omega = Omega(N, n).astype(float)     # log-sum-exp for Z to avoid overflow when f is large    logw = np.log(omega) + beta * f * Lgrid    logZ = logsumexp(logw)    Pf = np.exp(logw - logZ)                           # PMF on Lgrid    binw = 2*a    return Lgrid, Pf / binw                            # density for overlay# ---------- Large f -----------N = 100no_rubber_bands = 5000beta = 1.0a = 1.0# choose larger f — you’ll clearly see the shift & narrowingFs = [0.5, 1.0, 2.0, 3.0]fig, axes = plt.subplots(1, len(Fs), figsize=(4*len(Fs), 3), sharey=True)if len(Fs) == 1: axes = [axes]for f in Fs:    # MC    L = sample_biased_lengths(N, f, no_rubber_bands)    Lgrid, dens = analytic_Pf_density(N, f, a, beta)    edges = np.arange(Lgrid.min() - a, Lgrid.max() + a + 2*a, 2*a)    plt.figure(figsize=(4, 3))    plt.hist(L, bins=edges, density=True, alpha=0.35, edgecolor='k', label='MC')    # smooth analytic curve    x = np.linspace(Lgrid.min(), Lgrid.max(), 800)    y = make_interp_spline(Lgrid, dens)(x)    plt.plot(x, y, 'k-', lw=2, label='Analytic')    plt.xlim(0, 150)    plt.title(f"f = {f}")    plt.xlabel("L/a")    plt.ylabel("P(L/a)")    plt.legend(frameon=False)    plt.tight_layout()    plt.show()fvals = np.linspace(0, 3.0, 25)        # small → moderate → largeLm = []Ls = []for f in fvals:    Lsamp = sample_biased_lengths(N, f, 20_000)  # enough stats to smooth std    Lm.append(Lsamp.mean())    Ls.append(Lsamp.std(ddof=1))Lm = np.array(Lm); Ls = np.array(Ls)# Analytic curvesL_full   = N*a*np.tanh(beta*a*fvals)              # full resultL_linear = (N*a*a*beta) * fvals                   # Hooke (small-f)sigma_th = np.sqrt(N) / np.cosh(beta*a*fvals)     # sqrt(N) * sech(f)# <L> vs fplt.figure(figsize=(5,3))plt.plot(fvals, Lm, 'o', ms=3, label='MC ⟨L⟩')plt.plot(fvals, L_full, 'k-', lw=2, label='Analytic ⟨L⟩ = N tanh f')plt.plot(fvals, L_linear, 'k--', lw=1.5, label='Linear ⟨L⟩ ≈ N f')plt.xlabel("Force f"); plt.ylabel("⟨L⟩"); plt.legend(frameon=False); plt.tight_layout(); plt.show()