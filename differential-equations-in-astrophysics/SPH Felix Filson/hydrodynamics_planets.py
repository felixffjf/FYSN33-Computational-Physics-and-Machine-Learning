import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimation, PillowWriterfrom scipy.integrate import solve_ivpfrom matplotlib.cm import ScalarMappable# ------------------ particles & initial state ------------------data = np.loadtxt("Planet300.dat")alpha_Pi = 1beta_Pi = 1gamma = 1.4eta = 1.35G = 6.6743e-11dim = 3tfinal = 20000# numerical guardsEPS_RHO = 1e-12E_FLOOR = 1e-10vxi = 4e3vyi = 4e3offset = 5e7# column indicesx, y, z, vx, vy, vz, m, rho, p, e = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9planet1 = np.loadtxt("Planet600.dat")planet2 = np.loadtxt("Planet600.dat")planet3 = np.loadtxt("Planet600.dat")planet1[:,x] = -1e8*np.ones(len(planet1)) + planet1[:,x]planet2[:,x] = 1e8*np.ones(len(planet2)) + planet2[:,x]planet3[:,y] = 1e8*np.ones(len(planet3)) + planet3[:,y]planet1[:,y] = -offset*np.ones(len(planet1)) + planet1[:,y]planet2[:,y] = offset*np.ones(len(planet2)) + planet2[:,y]planet1[:,vx] = vxi*np.ones(len(planet1)) + planet1[:,vx]planet2[:,vx] = -vxi*np.ones(len(planet2)) + planet2[:,vx]planet3[:,vy] = -vyi*np.ones(len(planet3)) + planet3[:,vy]T1 = 4e4T2 = 4e4omegaz1 = 2*np.pi/T1omegaz2 = 2*np.pi/T2omega1 = np.array([0,0,omegaz1])omega2 = np.array([0,0,omegaz2])def add_spin_about_its_axis(planet, omega):    # mass-weighted COM    com = np.average(planet[:, (x, y, z)], weights=planet[:, m], axis=0)   # (3,)    r_rel = planet[:, (x, y, z)] - com                                     # (N,3)    v_spin = np.cross(omega, r_rel)                                        # Ω × r_rel    # remove tiny numerical net drift    v_spin -= np.average(v_spin, weights=planet[:, m], axis=0)    planet[:, (vx, vy, vz)] += v_spin    return planetplanet1 = add_spin_about_its_axis(planet1, omega1)planet2 = add_spin_about_its_axis(planet2, omega2)planet3 = add_spin_about_its_axis(planet3, omega2)state_vectors = np.concatenate((planet1,planet2), axis=0)e_ij = state_vectors[:,p]/((gamma-1)*state_vectors[:,rho])state_vectors = np.column_stack((state_vectors, e_ij))h = eta*(state_vectors[0,m]/state_vectors[0,rho])**(1/3)def rel_dist(S):    x_i = S[:,x][:,None]    x_j = S[:,x][None,:]    x_ij = x_i-x_j    y_i = S[:,y][:,None]    y_j = S[:,y][None,:]    y_ij = y_i-y_j    z_i = S[:,z][:,None]    z_j = S[:,z][None,:]    z_ij = z_i-z_j    dx = np.stack((x_ij,y_ij,z_ij), axis=-1)    r_ij = np.linalg.norm(dx, axis=-1)    R_ij = r_ij/h    return dx, r_ij, R_ijdef rel_vel(S):    vx_i = S[:,vx][:,None]    vx_j = S[:,vx][None,:]    vx_ij = vx_i-vx_j        vy_i = S[:,vy][:,None]    vy_j = S[:,vy][None,:]    vy_ij = vy_i-vy_j        vz_i = S[:,vz][:,None]    vz_j = S[:,vz][None,:]    vz_ij = vz_i-vz_j        v_ij = np.stack((vx_ij,vy_ij,vz_ij),axis=-1)    return v_ij    #---------------------helper functions--------------------def avg_rho(S):    rho_i_ = S[:,rho][:,None]    rho_j_ = S[:,rho][None,:]    return (rho_i_+rho_j_)/2def alpha_d(dim):    if dim == 1:        return 1/h    elif dim == 2:        return 15/(7*np.pi*(h**2))    elif dim == 3:        return 3/(2*np.pi*(h**3))def W(R, dim):    a = alpha_d(dim)    term1 = (2/3 - R**2 + 0.5*R**3) * a    term2 = ((2 - R)**3) * a / 6.0    return np.where(R < 1.0, term1, np.where(R < 2.0, term2, 0.0))def W_prime(R, dx, r_ij, dim):    a = alpha_d(dim)    safe_r = np.where(r_ij == 0.0, 1.0, r_ij)      # (N,N)    dWdr = np.where(        R < 1.0,        a * (-2.0*R + 1.5*R**2) / h,        np.where(R < 2.0,                 -0.5 * a * (2.0 - R)**2 / h,                 0.0)    )                                              # (N,N)    rhat = dx / safe_r[:, :, None]                 # (N,N,3)    return dWdr[:, :, None] * rhat                 # (N,N,3)def W_upd(S, dim):    _, _, R_ij = rel_dist(S)    return W(R_ij, dim)def W_prime_upd(S, dim):    dx, r_ij, R_ij = rel_dist(S)    return W_prime(R_ij, dx, r_ij, dim)def rho_i(S):    W_ij = W_upd(S,dim)    return np.sum(S[:,m]*W_ij, axis = 1) def e_pos(S):    return np.clip(S[:,e], E_FLOOR, None)def p_i(S):    r = rho_i(S)    return (gamma-1)*r*e_pos(S)def c_avg_ij(S):    c = np.sqrt((gamma-1)*e_pos(S))    return (c[:,None] + c[None,:])/2def phi_ij(S):    dx, r_ij, _ = rel_dist(S)    v_ij = rel_vel(S)    vdotdx = np.sum(v_ij * dx, axis=2)    return (h * vdotdx) / (r_ij**2 + (0.1*h)**2)def rho_bar_ij(S):    r = rho_i(S)    return 0.5*(r[:,None] + r[None,:])def Pi(S):    dx, r_ij, R_ij = rel_dist(S)    cond = np.sum(rel_vel(S) * dx, axis=2) < 0.0    phi = phi_ij(S)        return np.where(cond,                    (-alpha_Pi * c_avg_ij(S) * phi + beta_Pi * phi**2) / (rho_bar_ij(S) + EPS_RHO),                    0.0)def e_prime_i(S):    r = rho_i(S)    pEOS = (gamma-1)*r*e_pos(S)    denom_i2 = (r**2 + EPS_RHO)[:,None]    denom_j2 = (r**2 + EPS_RHO)[None,:]    pi_over = (pEOS[:,None]/denom_i2) + (pEOS[None,:]/denom_j2) + Pi(S)    e_prime_ij = S[:,m][None,:] * pi_over * np.sum(rel_vel(S)*W_prime_upd(S,dim), axis=2)    return 0.5 * np.sum(e_prime_ij, axis=1)def phi_prime(R, r):    safe_r = np.where(r==0, 1.0, r)    return np.where(R==0, 0, np.where(R<1, (1/h**2)*((4/3)*R - 1.2*R**3 + 0.5*R**4),                    np.where(R<2, (1/h**2)*((8/3)*R - 3*R**2 + 1.2*R**3 - (1/6)*R**4 - 1/(15*R**2)),                             1/safe_r**2)                    )                )def v_prime_i(S):    # --- hydro term ---    r   = rho_i(S)    pEOS = (gamma-1)*r*e_pos(S)    denom_i2 = (r**2 + EPS_RHO)[:, None]    denom_j2 = (r**2 + EPS_RHO)[None, :]    pij_over = (pEOS[:,None]/denom_i2) + (pEOS[None,:]/denom_j2) + Pi(S)  # (N,N)    gradW = W_prime_upd(S,dim)                          # (N,N,3)    m_j   = S[:, m][None, :, None]                  # (1,N,1)    hydro_ij = - m_j * pij_over[:, :, None] * gradW # (N,N,3)    # --- gravity term ---    dx, r_ij, R_ij = rel_dist(S)    safe_r = np.where(r_ij == 0.0, 1.0, r_ij)    dir_ij = dx / safe_r[:, :, None]                # (N,N,3)    dphi   = phi_prime(R_ij, safe_r)                # (N,N)    grav_ij = - G * m_j * dphi[:, :, None] * dir_ij # (N,N,3)          a_i = np.sum((hydro_ij + grav_ij), axis=1)       # (N,3)    return a_idef r_prime_i(S):    return np.column_stack((S[:,vx], S[:,vy], S[:,vz]))  # /N,3#------------Preparing matrices for RK45---------------def flatten(x_upd, v_upd, e_upd):    return np.concatenate([x_upd.reshape(-1), v_upd.reshape(-1), e_upd.reshape(-1)])def unflatten(y, N):    x_upd = y[:3*N].reshape(N,3)    v_upd = y[3*N:6*N].reshape(N,3)    e_upd = y[6*N:].reshape(N)    return x_upd, v_upd, e_upddef upd_S(S_static, x_upd, v_upd, e_upd):    S = S_static.copy()    S[:, (x,y,z)] = x_upd    S[:, (vx,vy,vz)] = v_upd    S[:, e] = e_upd    # recompute rho and p each step    S[:, rho] = rho_i(S)    S[:, p]   = (gamma-1)*S[:, rho]*e_pos(S)    return Sdef make_rhs(S_static):    N = S_static.shape[0]    def rhs(t, y):        x_upd, v_upd, e_upd = unflatten(y, N)        S = upd_S(S_static, x_upd, v_upd, e_upd)        a = v_prime_i(S)   # (N,3)        b = e_prime_i(S)   # (N,)        dydt = flatten(v_upd, a, b)        return dydt    return rhsN = state_vectors.shape[0]y0 = flatten(state_vectors[:,(x,y,z)], state_vectors[:,(vx,vy,vz)], state_vectors[:,e])rhs = make_rhs(state_vectors)#Run simulationsol = solve_ivp(rhs, [0, tfinal], y0, method="RK45", t_eval=np.linspace(0,tfinal,400))fig = plt.figure()ax = fig.add_subplot(111, projection="3d")Nframes = len(sol.t)scatter = ax.scatter([], [], [], c=[], cmap="viridis", s=5)# Add colorbarrho0 = rho_i(state_vectors)norm = plt.Normalize(vmin=rho0.min(), vmax=rho0.max())cmap = plt.get_cmap("viridis")fig = plt.figure()ax = fig.add_subplot(111, projection="3d")# draw first frame’s colors so colorbar is correctcolors0 = cmap(norm(rho0))scatter = ax.scatter(state_vectors[:,x], state_vectors[:,y], state_vectors[:,z],                     s=5, c=colors0)# colorbar driven by a ScalarMappable (not the scatter, which is 3D)sm = ScalarMappable(norm=norm, cmap=cmap)sm.set_array([])cbar = fig.colorbar(sm, ax=ax, shrink=0.6)cbar.set_label("Density")def init():    max_pos = np.max(np.concatenate((state_vectors[:,x],state_vectors[:,y],state_vectors[:,z])))    min_pos = np.min(np.concatenate((state_vectors[:,x],state_vectors[:,y],state_vectors[:,z])))    ax.set_xlim(min_pos,max_pos)    ax.set_ylim(min_pos,max_pos)    ax.set_zlim(min_pos,max_pos)    ax.set_title("Planet Collison 600 x 600(t=0s)")    return scatter,def update(frame):    x_upd, v_upd, e_upd = unflatten(sol.y[:, frame], N)    S = upd_S(state_vectors, x_upd, v_upd, e_upd)    com = np.average(x_upd, weights=S[:, m], axis=0)    X = x_upd - com  # visualize in COM frame    rho_vals = rho_i(S)    # move points    scatter._offsets3d = (X[:,0], X[:,1], X[:,2])    # update colors explicitly (3D scatter often ignores set_array)    colors = cmap(norm(rho_vals))    scatter.set_facecolor(colors)    # OPTIONAL: expand color scale if new values exceed initial range    if rho_vals.min() < norm.vmin or rho_vals.max() > norm.vmax:        norm.vmin = min(norm.vmin, rho_vals.min())        norm.vmax = max(norm.vmax, rho_vals.max())        sm.set_norm(norm)        cbar.update_normal(sm)    ax.set_title(f"Planet Collision 600 x 600 (t={sol.t[frame]:.2f}s)")    return scatter,ani = FuncAnimation(fig, update, frames=Nframes, init_func=init, blit=False, interval=50)# Show interactivelyplt.show()# Save as GIFani.save("particles.gif", writer=PillowWriter(fps=20))